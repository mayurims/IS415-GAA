---
title: "Take-Home Excercise 02"
author: "Mayuri Salunke"
date: "30 January 2023"
date-modified: "`r Sys.Date()`"
execute: 
  echo: true
  eval: true
  message: false
  warning: false
editor: visual
---

# 1.0 Overview

wehsbf kjefnb erng lkdjgn elrgnlrk lreig

# 2.0 Setup

## 2.1 Packages Used

-   sf : Used for importing geospatial data, assigning or transforming coordinate systems, and converting geospatial and aspatial data into a sf data frame

-   tidyverse : Used for transforming and better presentation of Data

-   tmap : Used for plotting static point patterns maps or interactive maps

-   spatstat : Used for point-pattern analysis

-   raster : Used to read, write, manipulate, analyse and model gridded spatial data

-   maptools : Used to provide a set of tools for manipulating geographic data

-   kableExtra : Used for table customization

-   sfdep : Used for functions creates not present in spdep.

-   readxl

-   knitr

```{r}
pacman::p_load(sf, tmap, kableExtra, tidyverse, sfdep, readxl, plyr, Kendall)
```

## 2.2 Datasets Used

```{r}
# initialise a dataframe of our geospatial and aspatial dataset details
datasets <- data.frame(
  Type=c("Geospatial",
         "Aspatial"),
  
  Name=c("DKI Jakarta Provincial Village Boundary",
         "District Based Vaccination History"),
  
  Format=c(".shp", 
           ".xlsx"),
  
  Source=c("(https://www.indonesia-geospasial.com/2020/04/download-shapefile-shp-batas-desa.html)",
           "(https://riwayat-file-vaksinasi-dki-jakarta-jakartagis.hub.arcgis.com/)"),
  
  Description=c("It has the District level boundary data of DKI Jakarta of 2019",
                "The muiliple excel files consists of all the vaccinations done at Village and District based.")
  )

# with reference to this guide on kableExtra:
# https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html
# kable_material is the name of the kable theme
# 'hover' for to highlight row when hovering, 'scale_down' to adjust table to fit page width
library(knitr)
library(kableExtra)
kable(datasets, caption="Datasets Used") %>%
  kable_material("hover", latex_options="scale_down")
```

Things to Note for Aspatial Data:

To retrieve the monthly cumulative records for the COVID-19 cases in Jakarta, I took the data compiled on the last of every month (e.g - 31st July, 30tt August ... ) from July 2021 to June 2022. I had started with taking first of every month, however, i realized that

Further, the data consists of the following groups -

-   Vaccination of Elderly (Lansia)

-   Vaccination of Public Servant (Pelayan Publik)

-   Mutual Cooperation (Goton Royong) Vaccination

-   Vaccination of Health Workers (Tenaga Kesehatan)

-   Stage 3 (Tahapan) Vaccinations

-   Vaccination of Teenagers (Remaja)

# 3.0 Data Wrangling : Geospatial Data

## 3.1 Importing Geospatial Data

We will begin by importing Geospatial data into R by using the st_read() of sf package. It imports the BATAS_DESA_DESEMBER_2019_DUKCAPIL_DKI_JAKARTA shapefile into R as a polygon data frame. We provide 2 arguments - dsn (which is the data path) and layer (the shapefile name)

```{r}
jakarta <- st_read(dsn="data/geospatial",
                   layer="BATAS_DESA_DESEMBER_2019_DUKCAPIL_DKI_JAKARTA")
```

From the output message, we learn that:

-   Geometry type is multipolygon

-   269 features, 161 fields

-   Assigned CRS is [WGS 84](https://epsg.io/4326), the 'World Geodetic System 1984'. This is not right, and will be rectified in \_\_\_\_

## 3.2 Data Pre-processing {data-link="3.2 Data Pre-processing"}

### 3.2.1 Dropping Invalid Dimensions

Since, we only have one dataframe, there are no invalid dimensions, and hence, this step is not required.

### 3.2.2 Missing Values

Now lets check if there are any missing values.

```{r}
jakarta[rowSums(is.na(jakarta))!=0,]
```

We can see that there are 2 rows containing 'NA' values. However, since the data is big, we need to find the columns with missing NA values so that we can work on it.

```{r}
names(which(colSums(is.na(jakarta))>0))
```

We can see that there are two particular rows with missing values for KAB_KOTA (City), KECAMATAN (District) and DESA_KELUR (Village).

Hence, we remove rows that NA value in DESA_KELUR. There are other columns present as well, however, since we are only looking at the sub-district level, it is most appropriate to remove DESA_KELUR

```{r}
jakarta <- na.omit(jakarta,c("DESA_KELUR"))
```

Lets double check if there the rows with missing values are removed.

```{r}
jakarta[rowSums(is.na(jakarta))!=0,]
```

### 3.2.3 Verifying + Transforming Coordinates

Now, we use the `st_crs()` to check the coordinate system of the data. As we can see, it uses the WGS 84 coordinate system. The data is using a Geographic projected system, however, this is system is not appropriate since we need to use distance and area measures.

```{r}
st_crs(jakarta)
```

Hence, we use `st_transform()` and not `st_set_crs()` as `st_set_crs()` assigns the EPSG code to the data frame. And we need to transform the data frame from geographic to projected coordinate system. We will be using crs=26392 (found from the [EPSG](https://epsg.io/?q=DGN95&page=3) for Indonesia).

```{r}
jakarta <- st_transform(jakarta, 23845)
```

Lets double check if CRS has been assigned

```{r}
st_crs(jakarta)
```

### 3.2.3 Removal of Outer Islands

Now that we have done our basic pre-processing, lets quickly visualise the data

```{r}
plot(st_geometry(jakarta))
```

As we can see from the diagram, `jakarta` includes both mainland and outer islands. And since we don't require the outer islands (as per the requirements), we can remove them.

**DIAGRAMM EXPLAINING THE DATAA**

We know that the date is grouped by KAB_KOTA (City), KECAMATAN (Sub-District) and DESA_KELUR (Village). Now, lets plot the map and see how we can use KAB_KOTA to remove the outer islands.

```{r}
tm_shape(jakarta) + 
  tm_polygons("KAB_KOTA")
```

From the map, we can see that all the cities in Jakarta start with 'Jakarta' as their prefix and hence, 'Kepulauan Seribu' are the other outer islands. When translated in English, the name means 'Thousand Islands'. Hence, now we know what to remove and we shall proceed with that.

```{r}
jakarta <- filter(jakarta, KAB_KOTA != "KEPULAUAN SERIBU")
```

Now, lets double check if the outer islands have been removed.

```{r}
tm_shape(jakarta) + 
  tm_polygons("KAB_KOTA")
```

### 3.2.4 Retaining first 9 fields of `jakarta`

**WHYY THOUGHHH??? I DONT GETTT ITTT**

Additionally, the assignment only requires us to retain the relevant fields - which are the first 9 fields.

```{r}
jakarta <- jakarta[, 0:9]
```

### 3.2.5 Renaming Columns with Translation

Since the columns names are in Indonesian, lets rename them to English for better ease of use.

**HOW DOO YOU FIND THE LEVELSSSS?????????**

```{r}
jakarta <- jakarta %>% 
  
  dplyr::rename(
    
    Object_ID=OBJECT_ID,
    Village_Code=KODE_DESA, 
    
    # fifth level
    Village=DESA,
    Code=KODE,
    
    # first level
    Province=PROVINSI, 
    
    # second level
    City=KAB_KOTA, 
    
    # third level
    District=KECAMATAN, 
    
    # fourth level
    Sub_District=DESA_KELUR,
    Total_Population=JUMLAH_PEN
    )
```

# 4.0 Data Wrangling : Aspatial Data

## 4.1 Pre-Importing EDA

For this assignment, we will be working on data from July 2021 to June 2022, as a result we will be having several excel files. Hence, it is safe to preview the data first and check for any discrepancies, before compiling all the data.

```{r}
jul2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Juli 2021).xlsx")
glimpse(jul2021)
```

The above output shows that there are no duplicates. So we will check for all of them just to ensure that there are no duplicates and no inconsistencies

::: panel-tabset
**August 2021**

```{r}
aug2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Agustus 2021).xlsx")
glimpse(aug2021)
```

**September 2021**

```{r}
sep2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 September 2021).xlsx")
glimpse(sep2021)
```

**October 2021**

```{r}
oct2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Oktober 2021).xlsx")
glimpse(oct2021)
```

**November 2021**

```{r}
nov2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 November 2021).xlsx")
glimpse(nov2021)
```

**December 2021**

```{r}
dec2021 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Desember 2021).xlsx")
glimpse(dec2021)
```

**January 2021**

```{r}
jan2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Januari 2022).xlsx")
glimpse(jan2022)
```
:::

::: panel-tabset
**February 2022**

```{r}
feb2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (27 Februari 2022).xlsx")
glimpse(feb2022)
```

**March 2022**

```{r}
mar2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Maret 2022).xlsx")
glimpse(mar2022)
```

**April 2022**

```{r}
apr2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 April 2022).xlsx")
glimpse(apr2022)
```

**May 2022**

```{r}
may2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (31 Mei 2022).xlsx")
glimpse(may2022)
```

**June 2022**

```{r}
jun2022 <- read_xlsx("data/aspatial/Data Vaksinasi Berbasis Kelurahan (30 Juni 2022).xlsx")
glimpse(jun2022)
```
:::

As we can see, till February 2022, the number of columns is 27. However, from March 2022 the number of columns is 34. Upon researching about the difference between the number of columns, i realized that the data files from March 2022 has a separate column for Dosage 3, where has all the data files before March 2022 don't have any dosage 3 column. This could attribute to the the fact that, dosage 3 vaccination was only provided from March 2022.

Hence, we will address this issue in the next section.

## 4.2 Creating an Aspatial Data Pre-Processing Function

For the assignment, we don't require all the columns. Only the following columns are required -

-   KODE KELURAHAN (Sub-District Code)

-   KELURAHAN (Sub-District)

-   SASARAN (Target)

-   BELUM VASKIN (Yet to be vaccinated / Not yet vaccinated)

This solves the issue of some months having extra columns. However, we need to create an 'Date' column that shows the month and year of the observation, which is originally the file name. Each file has the naming convention 'Data Vaksinasi Berbasis Keluarahan (DD Month YYYY).

We will be combining the mentioned steps into a function

```{r}
# takes in an aspatial data filepath and returns a processed output
aspatial_preprocess <- function(filepath){
  # We have to remove the first row of the file (subheader row) and hence, we use [-1,] to remove it.
  result_file <- read_xlsx(filepath)[-1,]
  
  # We then create the Date Column, the format of our files is: Data Vaksinasi Berbasis Kelurahan (DD Month YYYY)
  # While the start is technically "(", "(" is part of a regular expression and leads to a warning message, so we'll use "Kelurahan" instead. The [[1]] refers to the first element in the list.
  # We're loading it as DD-Month-YYYY format
  # We use the length of the filepath '6' to get the end index (which has our Date)
  # as such, the most relevant functions are substr (returns a substring) and either str_locate (returns location of substring as an integer matrix) or gregexpr (returns a list of locations of substring)
  # reference https://stackoverflow.com/questions/14249562/find-the-location-of-a-character-in-string
  startpoint <- gregexpr(pattern="Kelurahan", filepath)[[1]] + 11
  
  result_file$Date <- substr(filepath, startpoint, nchar(filepath)-6)
  
  # Retain the Relevant Columns
  result_file <- result_file %>% 
    select("Date", 
           "KODE KELURAHAN", 
           "KELURAHAN", 
           "SASARAN", 
           "BELUM VAKSIN")
  return(result_file)
}
```

## 4.3 Feeding files into the aspatial_preprocess function

Instead of manually feeding the files, line by line, we will be using the function list.files() and lapply() to get our process done faster!

```{r}
# in the folder 'data/aspatial', find files with the extension '.xlsx' and add it to our fileslist 
# the full.names=TRUE prepends the directory path to the file names, giving a relative file path - otherwise, only the file names (not the paths) would be returned 
# reference: https://stat.ethz.ch/R-manual/R-devel/library/base/html/list.files.html
fileslist <-list.files(path = "data/aspatial", pattern = "*.xlsx", full.names=TRUE)

# afterwards, for every element in fileslist, apply aspatial_process function
dflist <- lapply(seq_along(fileslist), function(x) aspatial_preprocess(fileslist[x]))
```

We will then convert the dflist into an actual dataframe with ldply() using the below code

```{r}
vaccination_jakarta <- ldply(dflist, data.frame)
```

Now, lets take a look into our data

```{r}
glimpse(vaccination_jakarta)
```

## 4.4 Formatting Date Column

As we know the Dates are in Bahasa Indonesia, and hence, we need to translate them to English for ease of use. However, since the values in Date column were derived from substrings, they are in a string format and hence, first need to be converted to datetime.

```{r}
# parses the 'Date' column into Month(Full Name)-YYYY datetime objects
# reference: https://stackoverflow.com/questions/53380650/b-y-date-conversion-gives-na

# locale="ind" means that the locale has been set as Indonesia
Sys.setlocale(locale="ind")
```

```{r}
vaccination_jakarta$Date <- c(vaccination_jakarta$Date) %>% 
  as.Date(vaccination_jakarta$Date, format ="%d %B %Y")

glimpse(vaccination_jakarta)
```

## 4.5 Renaming the Column names into English

We now rename the column names into English for ease of use

```{r}
# renames the columns in the style New_Name = OLD_NAME
vaccination_jakarta <- vaccination_jakarta %>% 
  dplyr::rename(
    Date=Date,
    Sub_District_Code=KODE.KELURAHAN,
    Sub_District=KELURAHAN, 
    Target=SASARAN, 
    Not_Yet_Vaccinated=BELUM.VAKSIN
    )
```

```{r}
glimpse(vaccination_jakarta)
```

As we can see, the columns have successfully been renamed in English.

## 4.5 Further Data Processing

Now that we have our Aspatial data into our desired dataframe, lets perform any pre-processing to check out for anything we might have missed.

```{r}
vaccination_jakarta[rowSums(is.na(vaccination_jakarta))!=0,]
```

From the output, we can see there are no missing values.

# 5.0 Geospatial Data Integration

## 5.1 Preliminary joining + EDA

Now that we have both our Geospatial and Aspatial data, we need to join them. However, we need to first find a common header to join them.

```{r}
colnames(jakarta)
```

```{r}
colnames(vaccination_jakarta)
```

We can see that both the dataframes have Sub_District and hence we can join them by the Sub_District and Sub_District_Code (same as Village_Code in 'jakarta').

```{r}
# joins vaccination_jakarta to jakarta based on Sub_District and  Sub_District_Code
combined_jakarta <- left_join(jakarta, vaccination_jakarta,
                              by=c(
                                "Village_Code"="Sub_District_Code", 
                                "Sub_District"="Sub_District")
                              )
```

Now, lets take a look into the columns of combined_jakarta

```{r}
colnames(combined_jakarta)
```

We can then subcategorize the data into 'Target population to be Vaccinated' , 'Not Yet Vaccinated Population' and 'Total Population'

```{r}
target = tm_shape(combined_jakarta)+
  tm_fill("Target") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Target Count")

not_yet_vaccinated = tm_shape(combined_jakarta)+
  tm_fill("Not_Yet_Vaccinated") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Not Yet Vaccinated Count")

total_population = tm_shape(combined_jakarta)+
  tm_fill("Total_Population") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Total Population Count")

tmap_arrange(target, not_yet_vaccinated, total_population)
```

What is interesting to note, is that there seems to be 'Missing' value in the Target and Not_Yet_Vaccinated maps. Even though, when we had previously checked for missing values, it didn't show any missing values. However, we shall double check again.

```{r}
jakarta[rowSums(is.na(jakarta))!=0,]
```

```{r}
vaccination_jakarta[rowSums(is.na(vaccination_jakarta))!=0,]
```

As seen, we don't have any mission values in our dataframes. Hence, the most likely reasons for the missing values must be due to mismatched values when we combined (left-join) the Geospatial and Aspatial data.

## 5.2 Identifying Mismatched Sub-District Records

Since, we had conducted left-join using the Sub-District, there must be a mismatch in the naming of the subdistricts. Lets check it by looking at the unique subdistrict names in both `jakarta` and `vaccination_jakarta`

```{r}
# checks for unique values of Sub_District in jakarta that aren't already present in vaccination_jakarta and vice versa
jakarta_subdistrict <- c(jakarta$Sub_District)
vaccination_subdistrict <- c(vaccination_jakarta$Sub_District)

unique(jakarta_subdistrict[!(jakarta_subdistrict %in% vaccination_subdistrict)])
```

```{r}
unique(vaccination_subdistrict[!(vaccination_subdistrict %in% jakarta_subdistrict)])
```

We can see that there are same names in both the list but are just written in different ways. However, there are 6 words in the `vaccination_subdistrict` which are not in the `jakarta_subdistrict`. We shall take a look into that after we first correct the mismatched values.

Now, lets view the differences --

```{r}
# initialise a dataframe of our cases vs bd subdistrict spelling
spelling <- data.frame(
  Aspatial_Cases=c("BALE KAMBANG", "HALIM PERDANA KUSUMAH", "JATI PULO", "KAMPUNG TENGAH", "KERENDANG", "KRAMAT JATI", "PAL MERIAM", "PINANG RANTI", "RAWA JATI"),
  Geospatial_BD=c("BALEKAMBAG", "HALIM PERDANA KUSUMA", "JATIPULO", "TENGAH", "KRENDANG", "KRAMATJATI", "PALMERIAM", "PINANGRANTI", "RAWAJATI")
  )

# with dataframe a input, outputs a kable
library(knitr)
library(kableExtra)
kable(spelling, caption="Mismatched Records") %>%
  kable_material("hover", latex_options="scale_down")
```

As we can see these records have the same name, except that there is not standardization on how it is to be written. As a result, there is a mismatch between them. So now, lets correct this mismatch

```{r}
# We are replacing the mistmatched values in jakarta with the correct value
jakarta$Sub_District[jakarta$Sub_District == 'BALEKAMBANG'] <- 'BALE KAMBANG'
jakarta$Sub_District[jakarta$Sub_District == 'HALIM PERDANA KUSUMA'] <- 'HALIM PERDANA KUSUMAH'
jakarta$Sub_District[jakarta$Sub_District == 'JATIPULO'] <- 'JATI PULO'
jakarta$Sub_District[jakarta$Sub_District == 'KALI BARU'] <- 'KALIBARU'
jakarta$Sub_District[jakarta$Sub_District == 'TENGAH'] <- 'KAMPUNG TENGAH'
jakarta$Sub_District[jakarta$Sub_District == 'KRAMATJATI'] <- 'KRAMAT JATI'
jakarta$Sub_District[jakarta$Sub_District == 'KRENDANG'] <- 'KERENDANG'
jakarta$Sub_District[jakarta$Sub_District == 'PALMERIAM'] <- 'PAL MERIAM'
jakarta$Sub_District[jakarta$Sub_District == 'PINANGRANTI'] <- 'PINANG RANTI'
jakarta$Sub_District[jakarta$Sub_District == 'RAWAJATI'] <- 'RAWA JATI'
```

Now, lets look into the 6 subdistrict names that we say in `vaccination_jakarta` which were not present in `jakarta`. This ideally suggests that these districts are not a part of Jakarta, however, we need to double check it just to be sure.

![Unique Subdistricts](images/image-2131298069.png)

![Subdistricts in Jakarta](images/image-779347305.png)

This can be verified by taking a look at our excel file. The 2nd screenshot shows the subdistricts in Jakarta as they have the name Jakarta in 'WILAYAH KOTA' which means City Area. However, as seen in the 1st screenshot, these 6 subdistricts do not have the name Jakarta in 'WILAYAH KOTA' confirming the fact that they are not a part of Jakarta. Hence, we need to remove them.

```{r}
vaccination_jakarta <- vaccination_jakarta[!(vaccination_jakarta$Sub_District=="PULAU HARAPAN" | vaccination_jakarta$Sub_District=="PULAU KELAPA" | vaccination_jakarta$Sub_District=="PULAU PANGGANG" | vaccination_jakarta$Sub_District=="PULAU PARI" | vaccination_jakarta$Sub_District=="PULAU TIDUNG" | vaccination_jakarta$Sub_District=="PULAU UNTUNG JAWA"), ]
```

## 5.3 Rejoining + EDA

Now, that we have a more standardized common identifier and have removed all the unnecessary values from our data, we can join them again once more!

```{r}
# joins vaccination_jakarta to jakarta based on Sub_District and  Sub_District_Code
combined_jakarta <- left_join(jakarta, vaccination_jakarta,
                              by=c(
                                "Village_Code"="Sub_District_Code", 
                                "Sub_District"="Sub_District")
                              )
```

```{r}
# Join vaccination_jakarta to jakarta based on Sub_District.
#combined_jakarta <- left_join(jakarta, vaccination_jakarta,
                              #by=c("Sub_District"="Sub_District")
                              #)
```

Let's check if there are any NA values now

```{r}
combined_jakarta[rowSums(is.na(combined_jakarta))!=0,]
```

Let's re-visualize the data into 'Target population to be Vaccinated' , 'Not Yet Vaccinated Population' and 'Total Population'

```{r}
target = tm_shape(combined_jakarta)+
  tm_fill("Target") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Target Count")

not_yet_vaccinated = tm_shape(combined_jakarta)+
  tm_fill("Not_Yet_Vaccinated") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Not Yet Vaccinated Count")

total_population = tm_shape(combined_jakarta)+
  tm_fill("Total_Population") +
  tm_borders(alpha = 0.5) +
  tm_layout(main.title="Total Population Count")

tmap_arrange(target, not_yet_vaccinated, total_population)
```

# 
6.0 Calculations for Vaccination Rate

Before we proceed with EDA and Thematic mapping, we need to compute the monthly vaccination rate (in %) at the sub-district level

$$
Vaccination Rate = ((Target - Numberofpeople not vaccinated) / Target) * 100
$$

Note : We use 'Target' (SASARAN) instead of Population, as the Indonesian government excludes people aged 14 and below for vaccination. As a result, they will be excluded from the total population.

```{r}
# grouping based on the sub-district and date
vaccination_rate <- vaccination_jakarta %>%
  inner_join(jakarta, by=c("Sub_District" = "Sub_District")) %>%
  group_by(Sub_District, Date) %>%
  dplyr::summarise(`vaccination_rate` = ((Target-Not_Yet_Vaccinated)/Target)*100) %>%
  
  #afterwards, pivots the table based on the Dates, using the cumulative case rate as the values
  ungroup() %>% pivot_wider(names_from = Date,
              values_from = vaccination_rate)
```

Now, lets look at how computed vaccination_rate looks like

```{r}
vaccination_rate
```

## 
6.1 Converting dataframs to sf objects

Before we move on into the mapping, we need to convert the dataframes into sf objects. We will convert combined_jakarta and vaccination_rate which will be using for our analysis.

```{r}
combined_jakarta <- st_as_sf(combined_jakarta)

# need to join our previous dataframes with the geospatial data to ensure that geometry column is present
vaccination_rate <- vaccination_rate%>% left_join(jakarta, by=c("Sub_District"="Sub_District"))
vaccination_rate <- st_as_sf(vaccination_rate)
```

# 7.0 Choropleth Mapping and Anlaysis

There are multiple ways to classify data in Choropleth maps, here are the some of them -

1.  Equal Interval - This method divides the range of data into equal-sized intervals. However, this can be misleading as it does not take into account the distribution of values
2.  Quantile - This method divides the data into equal-sized groups, each containing an equal number of data points. However, they are quite sensitive to outliers
3.  Jenks - This method uses statistical algorithm to group data into classes based on natural break/gaps in the distribution of values (even with low variance).

For this assignment, I am choosing the Jenks classification method as it seeks to minimize the variance within each group while maximizing the variance between groups. As a result it accurately reflects the distribution of values in the data.

## 7.1.1 Jenks Choropleth Maps

After testing, I have decided to stick to 6 classes, as too many classes makes it hard for the human eye to differentiate between the gradients, while too few makes it hard for any differentiation to be seen. Hence, 6 classes is the optimum number of classes.

```{r}
# using the jenks method, with 6 classes
tmap_mode("plot")
tm_shape(vaccination_rate)+
  tm_fill("2021-07-31", 
          n= 6,
          style = "jenks", 
          title = "Vaccination Rate") +
  tm_layout(main.title = "Distribution of Vaccination Rate in July 2021",
            main.title.position = "center",
            main.title.size = 1,
            legend.height = 0.5, 
            legend.width = 0.4,
            frame = TRUE) +
  tm_borders(alpha = 0.5)
```

We have to plot it for all the months, hence, let's have a function to help us do it!

```{r}
# input: the dataframe and the variable name - in this case, the month 
# with style="jenks" for the jenks classification method
jenks_plot <- function(df, varname) {
  tm_shape(vaccination_rate) +
    tm_polygons() +
  tm_shape(df) +
    tm_fill(varname, 
          n= 6,
          style = "jenks", 
          title = "Vaccination Rate") +
    tm_layout(main.title = varname,
          main.title.position = "center",
          main.title.size = 1.2,
          legend.height = 0.45, 
          legend.width = 0.35,
          frame = TRUE) +
    tm_borders(alpha = 0.5)
}
```

```{r}
tmap_mode("plot")
tmap_arrange(jenks_plot(vaccination_rate, "2021-07-31"),
             jenks_plot(vaccination_rate, "2021-08-31"),
             jenks_plot(vaccination_rate, "2021-09-30"),
             jenks_plot(vaccination_rate, "2021-10-31"))
```

```{r}
tmap_mode("plot")
tmap_arrange(jenks_plot(vaccination_rate, "2021-11-30"),
             jenks_plot(vaccination_rate, "2021-12-31"),
             jenks_plot(vaccination_rate, "2022-01-31"),
             jenks_plot(vaccination_rate, "2022-02-27"))
```

```{r}
tmap_mode("plot")
tmap_arrange(jenks_plot(vaccination_rate, "2022-03-31"),
             jenks_plot(vaccination_rate, "2022-04-30"),
             jenks_plot(vaccination_rate, "2022-05-31"),
             jenks_plot(vaccination_rate, "2022-06-30"))
```

Plotting all 12 maps together

```{r}
tmap_mode("plot")
tmap_arrange(jenks_plot(vaccination_rate, "2021-07-31"),
             jenks_plot(vaccination_rate, "2021-08-31"),
             jenks_plot(vaccination_rate, "2021-09-30"),
             jenks_plot(vaccination_rate, "2021-10-31"),
             jenks_plot(vaccination_rate, "2021-11-30"),
             jenks_plot(vaccination_rate, "2021-12-31"),
             jenks_plot(vaccination_rate, "2022-01-31"),
             jenks_plot(vaccination_rate, "2022-02-27"),
             jenks_plot(vaccination_rate, "2022-03-31"),
             jenks_plot(vaccination_rate, "2022-04-30"),
             jenks_plot(vaccination_rate, "2022-05-31"),
             jenks_plot(vaccination_rate, "2022-06-30")
             )
```

## 
7.1.2 Observations from Jenks Choropleth maps
